<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Product List | Stock System</title>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/style.css">
  <style>
    /* Basic styling for disabled pagination buttons */
    .pagination-btn {
      @apply px-3 py-1 rounded text-sm; /* Base styling */
    }
    .pagination-btn:not(.active) {
      @apply bg-gray-200 text-gray-700 hover:bg-gray-300; /* Default non-active style */
    }
    .pagination-btn:disabled {
      @apply bg-gray-200 text-gray-400 cursor-not-allowed;
    }
    .pagination-btn.active {
      @apply bg-blue-600 text-white; /* Active page style */
    }
  </style>
</head>
<body class="flex bg-gray-100 min-h-screen">

  <!-- Sidebar -->
  <%- include('partials/sidebar', { currentUser: currentUser, currentRole: currentRole }) %>

  <!-- Main Content -->
  <main class="flex-1 p-6 min-w-0">
    <div class="flex justify-between items-center mb-2">
      <h1 class="text-3xl font-bold">ðŸ“¦ Product List</h1>
      <button id="openAddProductBtn" class="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700 text-sm">+ Add New Product</button>
    </div>
    <p class="text-gray-700 mb-4 text-sm"><span id="productSummary">Loading products...</span></p>

    <!-- Filters -->
    <div class="flex flex-col md:flex-row md:items-center md:space-x-4 mb-6">
      <select id="categorySelect" class="p-2 border rounded mb-2 md:mb-0 text-sm">
        <option value="">-- All Categories --</option>
      </select>
      <input type="text" id="searchInput" placeholder="Search product..." class="p-2 border rounded flex-1 min-w-0 text-sm">
    </div>

    <!-- Product Table -->
    <div class="overflow-x-auto bg-white shadow rounded-lg min-w-0">
      <table class="min-w-full divide-y divide-gray-200 text-sm table-auto">
        <thead class="bg-gray-50">
          <tr>
            <th class="px-3 py-2 text-left font-medium text-gray-500 uppercase tracking-wider w-8">#</th>
            <th class="px-3 py-2 text-left font-medium text-gray-500 uppercase tracking-wider max-w-xs">Category</th>
            <th class="px-3 py-2 text-left font-medium text-gray-500 uppercase tracking-wider max-w-xs">Product Name</th>
            <th class="px-3 py-2 text-left font-medium text-gray-500 uppercase tracking-wider w-28">Action</th>
          </tr>
        </thead>
        <tbody id="productTable" class="bg-white divide-y divide-gray-200">
          <tr>
            <td colspan="4" class="text-center py-2 text-gray-500">Loading products...</td>
          </tr>
        </tbody>
      </table>
    </div>

    <!-- Pagination Controls -->
    <div id="paginationControls" class="flex justify-between items-center mt-6">
      <button id="prevPageBtn" class="pagination-btn px-4 py-2 bg-gray-300 text-gray-800 rounded hover:bg-gray-400">Previous</button>
      <div id="pageNumbers" class="flex space-x-2">
        <!-- Page number buttons will be injected here -->
      </div>
      <button id="nextPageBtn" class="pagination-btn px-4 py-2 bg-gray-300 text-gray-800 rounded hover:bg-gray-400">Next</button>
    </div>
  </main>

  <!-- Edit Modal -->
  <div id="editModal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50">
    <div class="bg-white p-6 rounded shadow-lg w-full max-w-md">
      <h2 class="text-xl font-semibold mb-4">Edit Product</h2>
      <form id="editForm">
        <div class="mb-4">
          <label class="block text-gray-700 mb-1">Category</label>
          <input type="text" id="editCategory" class="w-full p-2 border rounded text-sm" required>
        </div>
        <div class="mb-4">
          <label class="block text-gray-700 mb-1">Product Name</label>
          <input type="text" id="editProductName" class="w-full p-2 border rounded text-sm" required>
        </div>
        <div class="flex justify-end space-x-2">
          <button type="button" id="cancelEditBtn" class="px-4 py-2 border rounded hover:bg-gray-100">Cancel</button>
          <button type="submit" class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">Save</button>
        </div>
      </form>
    </div>
  </div>

  <!-- Add Product Modal -->
  <div id="addModal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50">
    <div class="bg-white p-6 rounded shadow-lg w-full max-w-md">
      <h2 class="text-xl font-semibold mb-4">Add New Product</h2>
      <form id="addForm">
        <!-- Category with Add button -->
        <div class="mb-4 flex items-center space-x-2">
          <select id="addCategory" class="w-full p-2 border rounded text-sm" required>
            <option value="">-- Select Category --</option>
          </select>
          <button type="button" id="addCategoryBtn" class="px-2 py-1 bg-gray-200 rounded hover:bg-gray-300 text-sm">+</button>
        </div>

        <!-- Product Name -->
        <div class="mb-4">
          <label class="block text-gray-700 mb-1">Product Name</label>
          <input type="text" id="addProductName" class="w-full p-2 border rounded text-sm" required>
        </div>

        <div class="flex justify-end space-x-2">
          <button type="button" id="cancelAddBtn" class="px-4 py-2 border rounded hover:bg-gray-100">Cancel</button>
          <button type="submit" class="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700">Add</button>
        </div>
      </form>
    </div>
  </div>

  <!-- Add Category Modal -->
  <div id="addCategoryModal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50">
    <div class="bg-white p-6 rounded shadow-lg w-full max-w-sm">
      <h3 class="text-lg font-semibold mb-4">Add New Category</h3>
      <form id="addCategoryForm">
        <input type="text" id="newCategoryName" class="w-full p-2 border rounded text-sm" placeholder="Category name" required>
        <div class="flex justify-end space-x-2 mt-4">
          <button type="button" id="cancelCategoryBtn" class="px-4 py-2 border rounded hover:bg-gray-100">Cancel</button>
          <button type="submit" class="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700">Add</button>
        </div>
      </form>
    </div>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', async () => {
      // --- DOM Elements ---
      const categorySelect = document.getElementById('categorySelect');
      const searchInput = document.getElementById('searchInput');
      const productTable = document.getElementById('productTable');
      const productSummary = document.getElementById('productSummary');

      const openAddProductBtn = document.getElementById('openAddProductBtn');
      const addModal = document.getElementById('addModal');
      const addForm = document.getElementById('addForm');
      const addCategorySelect = document.getElementById('addCategory');
      const addProductName = document.getElementById('addProductName');
      const cancelAddBtn = document.getElementById('cancelAddBtn');

      const addCategoryBtn = document.getElementById('addCategoryBtn');
      const addCategoryModal = document.getElementById('addCategoryModal');
      const addCategoryForm = document.getElementById('addCategoryForm');
      const newCategoryName = document.getElementById('newCategoryName');
      const cancelCategoryBtn = document.getElementById('cancelCategoryBtn');

      const editModal = document.getElementById('editModal');
      const editForm = document.getElementById('editForm');
      const editCategory = document.getElementById('editCategory');
      const editProductName = document.getElementById('editProductName');
      const cancelEditBtn = document.getElementById('cancelEditBtn');

      // Pagination elements
      const prevPageBtn = document.getElementById('prevPageBtn');
      const nextPageBtn = document.getElementById('nextPageBtn');
      const pageNumbersContainer = document.getElementById('pageNumbers');

      // --- Global State ---
      let allProducts = []; // This will now hold only the products for the current page
      let allCategories = [];
      let editingProductId = null;

      // Pagination State
      let currentPage = 1;
      const limit = 10; // Must match server's default limit
      let totalPages = 1;
      let totalItems = 0; // The total count of all products matching filters


      // --- Helper Functions (Declared first to ensure they are in scope) ---

      // --- Load Categories ---
      async function loadCategories() {
        try {
          const res = await fetch('/categories');
          allCategories = await res.json();
          // Populate both category dropdowns
          [categorySelect, addCategorySelect].forEach(select => {
            // Store current selected value to restore after repopulating
            const currentSelectedValue = select.value;

            select.innerHTML = `<option value="">-- All Categories --</option>`;
            allCategories.forEach(cat => {
              const opt = document.createElement('option');
              opt.value = cat;
              opt.textContent = cat.charAt(0).toUpperCase() + cat.slice(1);
              select.appendChild(opt);
            });

            // Restore previously selected value if it still exists
            if (currentSelectedValue && allCategories.includes(currentSelectedValue)) {
                select.value = currentSelectedValue;
            } else {
                select.value = ''; // Otherwise, select default
            }
          });
        } catch (err) {
          console.error('Error fetching categories:', err);
        }
      }

      // --- Render Products ---
      function renderProducts(products) {
        if (!products || products.length === 0) { // Check for null/undefined products as well
          productTable.innerHTML = `<tr><td colspan="4" class="text-center py-2 text-gray-500">No products found matching your criteria.</td></tr>`;
          productSummary.textContent = `Showing 0 to 0 of ${totalItems} results.`;
          return;
        }

        const startIndex = (currentPage - 1) * limit + 1;
        const endIndex = Math.min(startIndex + products.length - 1, totalItems);
        // Handle case where totalItems is 0 for productSummary text
        productSummary.textContent = `Showing ${startIndex} to ${endIndex} of ${totalItems} results.`;

        productTable.innerHTML = products.map((p, idx) => `
          <tr>
            <td class="px-3 py-2">${(currentPage - 1) * limit + idx + 1}</td>
            <td class="px-3 py-2 max-w-xs">${p.category || 'N/A'}</td>
            <td class="px-3 py-2 max-w-xs">${p.productName || 'N/A'}</td>
            <td class="px-3 py-2">
              <button class="text-blue-600 hover:underline edit-product-btn" data-id="${p._id}">Edit</button> |
              <button class="text-red-600 hover:underline delete-product-btn" data-id="${p._id}">Delete</button>
            </td>
          </tr>
        `).join('');

        // Re-attach event listeners after rendering new HTML
        document.querySelectorAll('.edit-product-btn').forEach(btn => {
          btn.addEventListener('click', () => openEditModal(btn.dataset.id));
        });
        document.querySelectorAll('.delete-product-btn').forEach(btn => {
          btn.addEventListener('click', () => deleteProduct(btn.dataset.id));
        });
      }

      // --- Render Pagination Controls ---
      function renderPagination() {
        pageNumbersContainer.innerHTML = ''; // Clear previous page numbers

        prevPageBtn.disabled = (currentPage === 1);
        nextPageBtn.disabled = (currentPage === totalPages || totalPages === 0);

        // Don't show pagination if there's only one page or no items
        if (totalPages <= 1) {
            document.getElementById('paginationControls').classList.add('hidden');
            return;
        } else {
            document.getElementById('paginationControls').classList.remove('hidden');
        }

        // Logic for displaying page numbers (e.g., 1 ... 4 5 [6] 7 8 ... 10)
        let startPage = Math.max(1, currentPage - 2);
        let endPage = Math.min(totalPages, currentPage + 2);

        // Adjust for cases near the beginning
        if (currentPage <= 3 && totalPages > 5) {
            startPage = 1;
            endPage = 5;
        }
        // Adjust for cases near the end
        if (currentPage >= totalPages - 2 && totalPages > 5) {
            startPage = Math.max(1, totalPages - 4);
            endPage = totalPages;
        }

        // Show first page and ellipsis if needed
        if (startPage > 1) {
            const firstPageBtn = document.createElement('button');
            firstPageBtn.textContent = '1';
            firstPageBtn.classList.add('pagination-btn');
            firstPageBtn.addEventListener('click', () => fetchProducts(1));
            pageNumbersContainer.appendChild(firstPageBtn);
            if (startPage > 2) {
                const ellipsis = document.createElement('span');
                ellipsis.textContent = '...';
                ellipsis.classList.add('px-2', 'py-1', 'text-gray-700');
                pageNumbersContainer.appendChild(ellipsis);
            }
        }

        // Render middle page numbers
        for (let i = startPage; i <= endPage; i++) {
          const pageBtn = document.createElement('button');
          pageBtn.textContent = i;
          pageBtn.classList.add('pagination-btn');
          if (i === currentPage) {
            pageBtn.classList.add('active');
          }
          pageBtn.addEventListener('click', () => fetchProducts(i));
          pageNumbersContainer.appendChild(pageBtn);
        }

        // Show last page and ellipsis if needed
        if (endPage < totalPages) {
            if (endPage < totalPages - 1) {
                const ellipsis = document.createElement('span');
                ellipsis.textContent = '...';
                ellipsis.classList.add('px-2', 'py-1', 'text-gray-700');
                pageNumbersContainer.appendChild(ellipsis);
            }
            const lastPageBtn = document.createElement('button');
            lastPageBtn.textContent = totalPages;
            lastPageBtn.classList.add('pagination-btn');
            lastPageBtn.addEventListener('click', () => fetchProducts(totalPages));
            pageNumbersContainer.appendChild(lastPageBtn);
        }
      }

      // --- Open Edit Product Modal ---
      function openEditModal(productId) {
        editingProductId = productId;
        // The product must be found from the currently displayed `allProducts` array
        const product = allProducts.find(p => p._id === productId);
        if (!product) {
            console.error('Product not found in current page data for ID:', productId);
            return;
        }
        editCategory.value = product.category || '';
        editProductName.value = product.productName || '';
        editModal.classList.remove('hidden');
        editModal.classList.add('flex');
      }

      // --- Delete Product ---
      async function deleteProduct(productId) {
        if (!confirm('Are you sure you want to delete this product?')) return;
        try {
          const res = await fetch(`/products/delete/${productId}`, { method: 'DELETE' });
          if (res.ok) {
            // After deleting, re-fetch products, potentially going to the previous page
            // if the last item on the current page was deleted.
            if (allProducts.length === 1 && currentPage > 1) {
                await fetchProducts(currentPage - 1);
            } else {
                await fetchProducts(currentPage);
            }
          } else {
            const errorData = await res.json();
            alert('Failed to delete product: ' + (errorData.message || res.statusText));
          }
        } catch (err) { console.error(err); alert('Error deleting product.'); }
      }

      // --- Fetch Products with Pagination and Filtering ---
      async function fetchProducts(page = currentPage) {
        currentPage = page; // Update global current page

        const selectedCategory = categorySelect.value;
        const searchQuery = searchInput.value.trim();

        let url = `/products/all?page=${currentPage}&limit=${limit}`;
        if (selectedCategory) url += `&category=${encodeURIComponent(selectedCategory)}`;
        if (searchQuery) url += `&search=${encodeURIComponent(searchQuery)}`;

        try {
          productTable.innerHTML = `<tr><td colspan="4" class="text-center py-2 text-gray-500">Loading products...</td></tr>`;
          productSummary.textContent = `Loading products...`;

          const res = await fetch(url);
          if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);

          const data = await res.json();
          allProducts = data.products; // Update products for the current page
          totalPages = data.totalPages;
          totalItems = data.totalProducts; // The overall total count
          currentPage = data.currentPage; // Ensure currentPage is in sync with server

          renderProducts(allProducts);
          renderPagination();

        } catch (err) {
          console.error('Error fetching products:', err);
          productTable.innerHTML = `<tr><td colspan="4" class="text-center py-2 text-red-500">Error loading products. Please try again.</td></tr>`;
          productSummary.textContent = `Error loading products.`;
        }
      }


      // --- Event Listeners for Modals ---
      cancelEditBtn.addEventListener('click', () => {
        editModal.classList.add('hidden');
        editingProductId = null;
      });

      editForm.addEventListener('submit', async e => {
        e.preventDefault();
        if (!editingProductId) return;
        const updatedData = {
          category: editCategory.value.trim(),
          productName: editProductName.value.trim()
        };
        try {
          const res = await fetch(`/products/edit/${editingProductId}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(updatedData)
          });
          if (res.ok) {
            await fetchProducts(currentPage); // Re-fetch current page to show updated product
            editModal.classList.add('hidden');
          } else {
            const errorData = await res.json();
            alert('Failed to update product: ' + (errorData.message || res.statusText));
          }
        } catch (err) { console.error(err); alert('Error updating product.'); }
      });

      openAddProductBtn.addEventListener('click', () => {
        addProductName.value = '';
        addCategorySelect.value = '';
        addModal.classList.remove('hidden');
        addModal.classList.add('flex');
      });

      cancelAddBtn.addEventListener('click', () => addModal.classList.add('hidden'));

      addForm.addEventListener('submit', async e => {
        e.preventDefault();
        const data = {
          category: addCategorySelect.value.trim(),
          productName: addProductName.value.trim()
        };
        try {
          const res = await fetch('/products/add', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data)
          });
          if (res.ok) {
            await fetchProducts(1); // Go to page 1 to ensure new product is visible
            addModal.classList.add('hidden');
          } else {
            const errorData = await res.json();
            alert('Failed to add product: ' + (errorData.message || res.statusText));
          }
        } catch (err) { console.error(err); alert('Error adding product.'); }
      });

      addCategoryBtn.addEventListener('click', () => {
        newCategoryName.value = '';
        addCategoryModal.classList.remove('hidden');
        addCategoryModal.classList.add('flex');
      });
      cancelCategoryBtn.addEventListener('click', () => addCategoryModal.classList.add('hidden'));

      // Add Category Submit Handler
      addCategoryForm.addEventListener('submit', async e => {
        e.preventDefault();
        const category = newCategoryName.value.trim();
        if (!category) {
            alert('Category name cannot be empty.');
            return;
        }
        try {
          const res = await fetch('/categories/add', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ category }) // Correctly sends { "category": "New Category Name" }
          });
          if (res.ok) {
            await loadCategories(); // Reload all category dropdowns
            // After loading, attempt to pre-select the newly added category if it's now in the list
            // This is especially important since your server-side logic only *acknowledges* the category
            // and it only appears in `Product.distinct()` after a product uses it.
            // So, this selection might only work if a product with that category already exists.
            const newCatOption = addCategorySelect.querySelector(`option[value="${category}"]`);
            if (newCatOption) {
                addCategorySelect.value = category;
            } else {
                addCategorySelect.value = ''; // Clear if not found
            }
            addCategoryModal.classList.add('hidden');
            // No need to fetchProducts here, as adding a category doesn't change product list immediately
            // unless a product with that category is also added.
            alert(`Category "${category}" name received. It will appear in dropdowns once a product is created with it.`);
          } else {
            const errorData = await res.json();
            alert('Failed to add category: ' + (errorData.message || res.statusText));
          }
        } catch (err) { console.error(err); alert('Error adding category.'); }
      });


      // --- Event Listeners for Filters & Pagination Controls ---
      categorySelect.addEventListener('change', () => fetchProducts(1)); // Reset to page 1 on filter change
      searchInput.addEventListener('input', () => fetchProducts(1));   // Reset to page 1 on search input

      prevPageBtn.addEventListener('click', () => {
        if (currentPage > 1) fetchProducts(currentPage - 1);
      });
      nextPageBtn.addEventListener('click', () => {
        if (currentPage < totalPages) fetchProducts(currentPage + 1);
      });

      // --- Initial Load ---
      await loadCategories();
      await fetchProducts(1); // Load the first page of products initially
    });
  </script>
</body>
</html>